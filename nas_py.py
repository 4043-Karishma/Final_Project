# -*- coding: utf-8 -*-
"""NAS.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RAmXnkKdqkJ97kg2e4sXEi3V02qY6Gq1
"""

!pip install tensorflow
!pip install keras-tuner
!pip install streamlit

import streamlit as st
import tensorflow as tf
from tensorflow import keras
import numpy as np
from kerastuner.tuners import RandomSearch

# Load CIFAR-10 Dataset
(x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()
x_train = x_train.astype('float32') / 255
x_test = x_test.astype('float32') / 255

# Define Hypermodel
def build_model(hp):
    model = keras.Sequential()
    model.add(keras.layers.Conv2D(
        filters=hp.Int('conv2d_filters', min_value=32, max_value=64, step=32),
        kernel_size=3,
        activation='relu',
        input_shape=(32, 32, 3)
    ))
    model.add(keras.layers.MaxPooling2D(pool_size=2))
    model.add(keras.layers.Flatten())
    model.add(keras.layers.Dense(
        units=hp.Int('dense_units', min_value=32, max_value=64, step=32),
        activation='relu'
    ))
    model.add(keras.layers.Dense(10, activation='softmax'))
    model.compile(
        optimizer=keras.optimizers.Adam(hp.Float('learning_rate', min_value=1e-3, max_value=1e-2, sampling='log')),
        loss='sparse_categorical_crossentropy',
        metrics=['accuracy']
    )
    return model

# Perform Neural Architecture Search
tuner = RandomSearch(
    build_model,
    objective='val_accuracy',
    max_trials=2,
    executions_per_trial=1,
    directory='my_dir',
    project_name='cifar10'
)
tuner.search(x_train[:1000], y_train[:1000], epochs=10, validation_data=(x_test[:100], y_test[:100]))

# Get Best Hyperparameters
best_hps = tuner.get_best_hyperparameters(num_trials=1)[0]

# Streamlit App
st.title("Neural Architecture Search for Optimized Image Classification")
st.write("Best Hyperparameters:")
st.write(f"Conv2D Filters: {best_hps.get('conv2d_filters')}")
st.write(f"Dense Units: {best_hps.get('dense_units')}")
st.write(f"Learning Rate: {best_hps.get('learning_rate')}")

best_model = tuner.hypermodel.build(best_hps)
best_model.fit(x_train[:1000], y_train[:1000], epochs=5, validation_data=(x_test[:100], y_test[:100]))
best_accuracy = best_model.evaluate(x_test[:100], y_test[:100])[1]
st.write(f"Best Model Accuracy: {best_accuracy:.2f}")